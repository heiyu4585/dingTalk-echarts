"use strict";

var _fastDeepEqual = _interopRequireDefault(require("fast-deep-equal"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function fmtEvent(props, e) {
  var dataset = {};
  for (var key in props) {
    if (/data-/gi.test(key)) {
      dataset[key.replace(/data-/gi, '')] = props[key];
    }
  }
  return Object.assign({}, e, {
    currentTarget: {
      dataset: dataset
    },
    target: {
      dataset: dataset,
      targetDataset: dataset
    }
  });
}
Component({
  props: {
    min: 0,
    max: 100,
    step: 1,
    ticks: false,
    range: false,
    disabled: false,
    showNumber: false,
    color: '#1677ff',
    tooltip: false,
    endMarks: false
  },
  data: {
    value: undefined,
    sliderLeft: 0,
    sliderWidth: 0,
    tickList: [],
    changingStart: false,
    changingEnd: false
  },
  didMount: function didMount() {
    var value = this.props.value;
    var sliderId = "dmt-slider-id-".concat(this.$id);
    this.setData({
      sliderId: sliderId
    });
    this.updateByProps(value, {
      isAfterChange: false,
      isSilentOnChange: true
    });
  },
  didUpdate: function didUpdate(prevProps) {
    if (!(0, _fastDeepEqual["default"])(this.props.value, prevProps.value)) {
      this.updateByProps(this.props.value, {
        isAfterChange: false,
        isSilentOnChange: true
      });
    } else if (!(0, _fastDeepEqual["default"])(this.props.min, prevProps.min) || !(0, _fastDeepEqual["default"])(this.props.max, prevProps.max) || !(0, _fastDeepEqual["default"])(this.props.step, prevProps.step) || !(0, _fastDeepEqual["default"])(this.props.range, prevProps.range) || !(0, _fastDeepEqual["default"])(this.props.ticks, prevProps.ticks)) {
      this.updateByProps(this.data.value, {
        isAfterChange: false,
        isSilentOnChange: true
      });
    }
  },
  methods: {
    updateByProps: function updateByProps(newValue) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$isAfterChange = _ref.isAfterChange,
        isAfterChange = _ref$isAfterChange === void 0 ? false : _ref$isAfterChange,
        _ref$isSilentOnChange = _ref.isSilentOnChange,
        isSilentOnChange = _ref$isSilentOnChange === void 0 ? true : _ref$isSilentOnChange;
      var _this$props = this.props,
        min = _this$props.min,
        max = _this$props.max,
        step = _this$props.step,
        range = _this$props.range,
        ticks = _this$props.ticks;
      var value = this.fitSliderValue(newValue, min, max, step, range);
      this.updateValue(value, step, {
        isAfterChange: isAfterChange,
        isSilentOnChange: isSilentOnChange
      });
      if (ticks) {
        this.setTickList(step, min, max);
      }
    },
    updateValue: function updateValue(value) {
      var step = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref2$isAfterChange = _ref2.isAfterChange,
        isAfterChange = _ref2$isAfterChange === void 0 ? false : _ref2$isAfterChange,
        _ref2$isSilentOnChang = _ref2.isSilentOnChange,
        isSilentOnChange = _ref2$isSilentOnChang === void 0 ? false : _ref2$isSilentOnChang;
      var _this$props2 = this.props,
        onChange = _this$props2.onChange,
        onAfterChange = _this$props2.onAfterChange;
      var prevValue = this.getRoundedValue(this.data.value, step);
      var currentValue = this.getRoundedValue(value, step);
      this.setData({
        value: currentValue
      });
      this.setSliderStyleByValue(currentValue);
      if (!this.isSliderValueEqual(currentValue, prevValue) && typeof onChange === 'function' && !isSilentOnChange) {
        onChange(currentValue, fmtEvent(this.props));
      }
      if (isAfterChange && typeof onAfterChange === 'function') {
        onAfterChange(currentValue, fmtEvent(this.props));
      }
    },
    getRoundedValue: function getRoundedValue(value) {
      var step = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (value === undefined) {
        return 0;
      }
      if (typeof value === 'number') {
        return Math.round(value / step) * step;
      }
      return [Math.round(value[0] / step) * step, Math.round(value[1] / step) * step];
    },
    setSliderStyleByValue: function setSliderStyleByValue(roundedValue) {
      var leftValue = 0;
      var rightValue = 0;
      var max = this.props.max === undefined ? sliderDefaultProps.max : this.props.max;
      var min = this.props.min === undefined ? sliderDefaultProps.min : this.props.min;
      if (roundedValue !== undefined) {
        if (typeof roundedValue === 'number') {
          leftValue = min;
          rightValue = roundedValue;
        } else {
          leftValue = roundedValue[0];
          rightValue = roundedValue[1];
        }
      }

      // FIX_ME when min and max is equal
      var width = (rightValue - leftValue) / (max - min) * 100;
      var left = (leftValue - min) / (max - min) * 100;
      this.setData({
        sliderLeft: left,
        sliderWidth: width
      });
    },
    setTickList: function setTickList(step, min, max) {
      var tickList = [];
      var stepCount = (max - min) / step;
      for (var i = 0; i <= stepCount; i += 1) {
        tickList.push({
          left: i * (100 / stepCount),
          value: i * step
        });
      }
      this.setData({
        tickList: tickList
      });
    },
    onTouchChanged: function onTouchChanged(e, type) {
      var _this = this;
      if (this.props.disabled) {
        return;
      }
      var changeMoving = function changeMoving(params) {
        var newParams = {};
        for (var key in params) {
          if (params[key] !== _this.data[key]) {
            newParams[key] = params[key];
          }
        }
        if (Object.keys(newParams).length > 0) {
          _this.setData(newParams);
        }
      };
      if (e.currentTarget && e.changedTouches[0]) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        my.createSelectorQuery().select("#".concat(e.currentTarget.id)).boundingClientRect().exec(function (list) {
          var element = list[0];
          if (element) {
            var touch = e.changedTouches[0];
            var touchPosition = (touch.pageX - element.left) / element.width;
            var value = _this.props.min + touchPosition * (_this.props.max - _this.props.min);
            if (!_this.props.range) {
              _this.updateValue(_this.fitSliderValue(value, _this.props.min, _this.props.max, _this.props.step, _this.props.range), _this.props.step);
              changeMoving({
                changingEnd: true
              });
            } else {
              var currentValue = _this.fitSliderValue(_this.data.value, _this.props.min, _this.props.max, _this.props.step, _this.props.range);
              var leftValue = currentValue[0];
              var rightValue = currentValue[1];
              var leftDistance = Math.abs(leftValue - value);
              var rightDistance = Math.abs(rightValue - value);
              var isFarFromLeft = leftDistance > rightDistance;
              var farValue = isFarFromLeft ? leftValue : rightValue;
              _this.updateValue(_this.fitSliderValue([value, farValue], _this.props.min, _this.props.max, _this.props.step, _this.props.range), _this.props.step);
              if (isFarFromLeft) {
                changeMoving({
                  changingEnd: true
                });
              } else {
                changeMoving({
                  changingStart: true
                });
              }
            }
          }
          if (type === 'end') {
            changeMoving({
              changingEnd: false,
              changingStart: false
            });
          }
        });
      }
    },
    cloneSliderValue: function cloneSliderValue(value) {
      if (_typeof(value) === 'object') {
        return [value[0], value[1]];
      }
      return value;
    },
    isSliderValueEqual: function isSliderValueEqual(value1, value2) {
      if (value1 === value2) {
        return true;
      }
      if (value1 === undefined || value2 === undefined) {
        return false;
      }
      if (typeof value1 === 'number' || typeof value2 == 'number') {
        return value1 === value2;
      }
      if (value1[0] === value2[0] && value1[1] === value2[1]) {
        return true;
      }
      return false;
    },
    fitSliderValue: function fitSliderValue(value, min, max, step, isRange) {
      if (value === undefined) {
        if (isRange) {
          return [min, min];
        } else {
          return min || 0;
        }
      }
      if (typeof value === 'number') {
        if (value > max) {
          return max;
        }
        if (value < min) {
          return min;
        }
        return Math.round(value);
      }
      var leftValue = Math.min(value[0], value[1]);
      var rightValue = Math.max(value[0], value[1]);
      return [Math.max(min, leftValue), Math.min(max, rightValue)];
    },
    handleTrackTouchStart: function handleTrackTouchStart(e) {
      this.onTouchChanged(e, 'start');
    },
    handleTrackTouchMove: function handleTrackTouchMove(e) {
      this.onTouchChanged(e, 'move');
    },
    handleTrackTouchEnd: function handleTrackTouchEnd(e) {
      var onAfterChange = this.props.onAfterChange;
      this.onTouchChanged(e, 'end');
      if (typeof onAfterChange === 'function') {
        this.updateByProps(this.data.value, {
          isAfterChange: true,
          isSilentOnChange: false
        });
      }
    }
  }
});
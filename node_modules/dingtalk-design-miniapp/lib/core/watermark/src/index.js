"use strict";

var acos30 = 1.732;
var asin30 = 2;
var charSize = 6.5 * 3;
var margin = 80 * 3;
Component({
  mixins: [],
  data: {
    $uiName: 'watermark',
    watermarkPath: '',
    width: 1000,
    height: 1000
  },
  props: {
    className: '',
    markers: ['水印文字'],
    show: true,
    slotWidth: 375,
    backgroundColor: '#FFFFFF',
    opacity: 0.04
  },
  didMount: function didMount() {
    this.renderMark();
  },
  didUpdate: function didUpdate(preProps) {
    var _this$props = this.props,
      markers = _this$props.markers,
      opacity = _this$props.opacity;
    if (preProps.markers.toString() !== markers.toString() || preProps.opacity !== opacity) {
      this.renderMark();
    }
  },
  methods: {
    renderMark: function renderMark() {
      var _this = this;
      var _this$props2 = this.props,
        markers = _this$props2.markers,
        opacity = _this$props2.opacity;
      var standarMarkers = this.formatMarker(markers);
      var longestMark = this.getLongestMark(standarMarkers);
      this.setData({
        width: longestMark * charSize / asin30 * acos30 + margin,
        height: this.getCharLength(standarMarkers[0]) * charSize / asin30 + margin * (standarMarkers.length - 1) + charSize * 5
      }, function () {
        var ctx = my.createCanvasContext('canvas');
        _this.ctx = ctx;
        ctx.setFillStyle("rgba(25,31,37,".concat(opacity, ")"));
        ctx.setFontSize(charSize * 2);
        _this.writeMark(standarMarkers);
        ctx.setFillStyle('rgba(255,255,255,0.12)');
        _this.writeMark(standarMarkers);
        ctx.draw();
        ctx.toTempFilePath({
          success: function success(path) {
            _this.setData({
              watermarkPath: path.filePath || path.apFilePath || path.tempFilePath || ''
            });
          }
        });
      });
    },
    getLongestMark: function getLongestMark(markers) {
      var _this2 = this;
      var markersLength = markers.map(function (mark) {
        return _this2.getCharLength(mark);
      });
      markersLength.sort(function (pre, next) {
        return pre - next;
      });
      return markersLength.pop();
    },
    getCharLength: function getCharLength(str) {
      var totalCount = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c >= 0x0001 && c <= 0x007e || c >= 0xff60 && c <= 0xff9f) {
          totalCount += 1;
        } else {
          totalCount += 2;
        }
      }
      return totalCount;
    },
    writeMark: function writeMark(markers) {
      var ctx = this.ctx;
      var startY = this.getCharLength(markers[0]) * charSize / asin30 + charSize * 2;
      markers.forEach(function (mark, i) {
        ctx.translate(10, startY + i * margin);
        ctx.rotate(-30 * Math.PI / 180);
        ctx.fillText(mark, 0, 0);
        ctx.rotate(30 * Math.PI / 180);
        ctx.translate(-10, -(startY + i * margin));
      });
    },
    formatMarker: function formatMarker(markers) {
      var _this3 = this;
      return markers && markers instanceof Array ? markers.map(function (marker) {
        if (_this3.getCharLength(marker) > 30) {
          console.warn("dingtalk-design-miniapp:\u3010watermark\u3011expected every string no longer than 30 chars, but recieved string as '".concat(marker, "'"));
          var str = '';
          marker.split('').some(function (_char) {
            if (_this3.getCharLength(str + _char) <= 30) {
              str += _char;
              return false;
            } else {
              return true;
            }
          });
          return str;
        } else {
          return marker;
        }
      }) : [''];
    }
  }
});